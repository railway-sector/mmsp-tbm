{"version":3,"file":"static/js/62075.7dd92ac2.chunk.js","mappings":"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","sources":["../node_modules/src/.internal/charts/xy/axes/CategoryAxis.ts"],"sourcesContent":["import type { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport type { Tooltip } from \"../../../core/render/Tooltip\";\nimport type { IXYSeriesDataItem, XYSeries } from \"../series/XYSeries\";\n\nimport { Axis, IAxisSettings, IAxisPrivate, IAxisDataItem, IAxisEvents } from \"./Axis\";\nimport { populateString } from \"../../../core/util/PopulateString\";\nimport { ValueAxis } from \"./ValueAxis\";\n\nimport * as $array from \"../../../core/util/Array\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $utils from \"../../../core/util/Utils\";\n\nexport interface ICategoryAxisSettings<R extends AxisRenderer> extends IAxisSettings<R> {\n\n\t/**\n\t * A function that can be used to specify how to configure axis fills.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Axis_fills} for more info\n\t */\n\tfillRule?: (dataItem: DataItem<ICategoryAxisDataItem>, index?: number) => void;\n\n\t/**\n\t * A field in data which holds categories.\n\t */\n\tcategoryField: string;\n\n\t/**\n\t * A key to look up in data for an id of the data item.\n\t */\n\tidField?: string;\n\n\t/**\n\t * A key to look up in data for a relative size value of the data item. \n\t */\n\tcellSizeField?: string;\n\n\t/**\n\t * Relative location of where axis cell starts: 0 - beginning, 1 - end.\n\t *\n\t * @default 0\n\t */\n\tstartLocation?: number;\n\n\t/**\n\t * Relative location of where axis cell ends: 0 - beginning, 1 - end.\n\t *\n\t * @default 1\n\t */\n\tendLocation?: number;\n}\n\nexport interface ICategoryAxisDataItem extends IAxisDataItem {\n\n\t/**\n\t * Named category.\n\t */\n\tcategory?: string;\n\n\t/**\n\t * Named end category (for axis items that span multiple categories, like\n\t * axis ranges).\n\t */\n\tendCategory?: string;\n\n\t/**\n\t * Index of the data item.\n\t */\n\tindex?: number;\n\n\t/**\n\t * Relative location of the category within cell: 0 - start, 1 - end.\n\t */\n\tcategoryLocation?: number;\n\n\t/**\n\t * Relative location of the end category within cell: 0 - start, 1 - end.\n\t */\n\tendCategoryLocation?: number;\n\n\t/**\n\t * A distance to shift data item relative to its original position.\n\t *\n\t * The value is 0 to 1, where 1 is full witdth of the axis.\n\t *\n\t * Can be used to sort data items without modifying order of the actual data.\n\t */\n\tdeltaPosition?: number;\n\n\t/**\n\t * A size of the category cell.\n\t *\n\t * NOTE: This value is used only if `cellSizeField` is set on the series.\n\t */\n\tcellSize?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tfinalCellSize?: number;\n\n\t/**\n\t * A unique id of the data item.\n\t */\n\tid?: string;\n}\n\nexport interface ICategoryAxisPrivate extends IAxisPrivate {\n\n\t/**\n\t * Start index of the current zoom scope.\n\t */\n\tstartIndex?: number;\n\n\t/**\n\t * End index of the current zoom scope.\n\t */\n\tendIndex?: number;\n}\n\nexport interface ICategoryAxisEvents extends IAxisEvents {\n\n}\n\n/**\n * Creates a category axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-axis/} for more info\n * @important\n */\nexport class CategoryAxis<R extends AxisRenderer> extends Axis<R> {\n\tpublic static className: string = \"CategoryAxis\";\n\tpublic static classNames: Array<string> = Axis.classNames.concat([CategoryAxis.className]);\n\n\tdeclare public _settings: ICategoryAxisSettings<R>;\n\tdeclare public _privateSettings: ICategoryAxisPrivate;\n\tdeclare public _dataItemSettings: ICategoryAxisDataItem;\n\tdeclare public _events: ICategoryAxisEvents;\n\n\tprotected _frequency: number = 1;\n\n\tprotected _itemMap: { [index: string]: DataItem<ICategoryAxisDataItem> } = {};\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tthis.fields.push(\"category\", \"id\", \"cellSize\");\n\t\tthis.setPrivateRaw(\"name\", \"category\");\n\t\tthis.addTag(\"category\");\n\t\tsuper._afterNew();\n\t}\n\n\tpublic _afterDataChange(): void {\n\t\tsuper._afterDataChange();\n\t\tconst len = this.dataItems.length;\n\t\tif (len > 0) {\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", len);\n\t\t}\n\n\t\t// fix final indexes\t\t\n\t\tthis.setPrivateRaw(\"startIndex\", Math.min(this.getPrivate(\"startIndex\", 0), len));\n\t\tthis.setPrivateRaw(\"endIndex\", Math.min(this.getPrivate(\"endIndex\", len), 1));\n\t}\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tconst len = this.dataItems.length;\n\t\tlet i = 0;\n\t\tif (this._valuesDirty) {\n\t\t\tthis._itemMap = {};\n\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\tdataItem.setRaw(\"index\", i);\n\t\t\t\tthis._itemMap[dataItem.get(\"category\") as string] = dataItem;\n\t\t\t\ti++;\n\t\t\t})\n\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", len);\n\t\t}\n\n\t\tlet start = this.get(\"start\", 0);\n\t\tlet end = this.get(\"end\", 1);\n\t\t\n\t\tlet indices = this._getIndices(start, end);\n\n\t\tthis.setPrivateRaw(\"startIndex\", indices.startIndex);\n\t\tthis.setPrivateRaw(\"endIndex\", indices.endIndex);\n\n\t\tif (this._sizeDirty || this._valuesDirty || (this.isDirty(\"start\") || this.isDirty(\"end\") || this.isPrivateDirty(\"endIndex\") || this.isPrivateDirty(\"startIndex\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\"))) {\n\t\t\tif (this.dataItems.length > 0) {\n\t\t\t\tthis._handleRangeChange();\n\t\t\t\tthis._prepareAxisItems();\n\t\t\t\tthis._updateAxisRanges();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic adjustZoom(): void {\n\t\tconst len = this.dataItems.length;\n\t\tif (len > 1) {\n\t\t\tlet maxZoomCount = this.get(\"maxZoomCount\", this.dataItems.length);\n\t\t\tlet minZoomCount = this.get(\"minZoomCount\", 1);\n\n\t\t\tlet count = 0;\n\t\t\tlet startIndex = this.getPrivate(\"startIndex\", 0);\n\t\t\tlet endIndex = this.getPrivate(\"endIndex\", 0);\n\n\t\t\tconst sAnimation = this._sAnimation;\n\t\t\tconst eAnimation = this._eAnimation;\n\n\t\t\tlet start = this.get(\"start\", 0);\n\t\t\tlet getIndices = false;\n\t\t\tif (sAnimation && !sAnimation.stopped) {\n\t\t\t\tstart = Number(sAnimation.to);\n\t\t\t\tgetIndices = true;\n\t\t\t}\n\t\t\tlet end = this.get(\"end\", 1);\n\t\t\tif (eAnimation && !eAnimation.stopped) {\n\t\t\t\tend = Number(eAnimation.to);\n\t\t\t\tgetIndices = true;\n\t\t\t}\n\n\t\t\tif (getIndices) {\n\t\t\t\tconst indices = this._getIndices(start, end);\n\t\t\t\tstartIndex = indices.startIndex;\n\t\t\t\tendIndex = indices.endIndex;\n\t\t\t}\n\n\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\tconst dataItem = this.dataItems[i];\n\t\t\t\tcount += dataItem.get(\"finalCellSize\", 1);\n\t\t\t};\n\n\t\t\tif (count <= minZoomCount) {\n\t\t\t\t// need to zoom out\n\t\t\t\tlet c = 0;\n\n\t\t\t\tfor (let i = startIndex; i < len; i++) {\n\t\t\t\t\tconst dataItem = this.dataItems[i];\n\t\t\t\t\tc += dataItem.get(\"finalCellSize\", 1);\n\n\t\t\t\t\tendIndex = i + 1;\n\t\t\t\t\tif (c >= minZoomCount) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (c < minZoomCount) {\n\t\t\t\t\t// still not enough, try to extend at the start\n\t\t\t\t\tfor (let i = startIndex - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst dataItem = this.dataItems[i];\n\t\t\t\t\t\tc += dataItem.get(\"finalCellSize\", 1);\n\t\t\t\t\t\tstartIndex = i;\n\t\t\t\t\t\tif (c >= minZoomCount) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.zoomToIndexes(startIndex, endIndex);\n\t\t\t}\n\t\t\telse if (count >= maxZoomCount) {\n\t\t\t\tlet c = count;\n\t\t\t\tfor (let i = endIndex - 1; i >= startIndex; i--) {\n\t\t\t\t\tconst dataItem = this.dataItems[i];\n\t\t\t\t\tc -= dataItem.get(\"finalCellSize\", 1);\n\t\t\t\t\tif (c <= maxZoomCount) {\n\t\t\t\t\t\tendIndex = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.zoomToIndexes(startIndex, endIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _handleRangeChange() {\n\t\t$array.each(this.series, (series) => {\n\t\t\tlet startCategory = this.dataItems[this.startIndex()].get(\"category\")!;\n\t\t\tlet endCategory = this.dataItems[this.endIndex() - 1].get(\"category\")!;\n\n\t\t\tlet baseAxis = series.get(\"baseAxis\");\n\t\t\tlet xAxis = series.get(\"xAxis\");\n\t\t\tlet yAxis = series.get(\"yAxis\");\n\n\t\t\tif (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {\n\t\t\t\tseries._markDirtyAxes();\n\t\t\t}\n\t\t\telse if (baseAxis === this) {\n\t\t\t\tlet key: string | undefined;\n\t\t\t\tlet openKey: string | undefined;\n\t\t\t\tlet otherAxis = yAxis;\n\t\t\t\tif (xAxis === baseAxis) {\n\t\t\t\t\tif (series.get(\"categoryXField\")) {\n\t\t\t\t\t\tkey = \"categoryX\";\n\t\t\t\t\t}\n\t\t\t\t\tif (series.get(\"openCategoryXField\")) {\n\t\t\t\t\t\topenKey = \"openCategoryX\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (yAxis === baseAxis) {\n\t\t\t\t\tif (series.get(\"categoryYField\")) {\n\t\t\t\t\t\tkey = \"categoryY\";\n\t\t\t\t\t}\n\t\t\t\t\tif (series.get(\"openCategoryYField\")) {\n\t\t\t\t\t\topenKey = \"openCategoryY\";\n\t\t\t\t\t}\n\t\t\t\t\totherAxis = xAxis;\n\t\t\t\t}\n\n\t\t\t\tif (otherAxis instanceof ValueAxis) {\n\n\t\t\t\t\tif (key || openKey) {\n\t\t\t\t\t\tlet startDataItem: DataItem<IXYSeriesDataItem> | undefined;\n\t\t\t\t\t\tlet endDataItem: DataItem<IXYSeriesDataItem> | undefined;\n\n\t\t\t\t\t\tfunction findDataItem(\n\t\t\t\t\t\t\tseries: XYSeries,\n\t\t\t\t\t\t\tcategoryAxis: CategoryAxis<any>,\n\t\t\t\t\t\t\tkey: string | undefined,\n\t\t\t\t\t\t\topenKey: string | undefined,\n\t\t\t\t\t\t\tcategory: string,\n\t\t\t\t\t\t\tdirection: \"previous\" | \"next\"\n\t\t\t\t\t\t): DataItem<IXYSeriesDataItem> | undefined {\n\t\t\t\t\t\t\tlet dataItem: DataItem<IXYSeriesDataItem> | undefined;\n\t\t\t\t\t\t\tlet idx = categoryAxis.categoryToIndex(category!);\n\n\t\t\t\t\t\t\twhile (!dataItem && idx >= 0 && idx < categoryAxis.dataItems.length) {\n\t\t\t\t\t\t\t\tlet searchCategory = categoryAxis.dataItems[idx].get(\"category\");\n\t\t\t\t\t\t\t\tif (direction == \"previous\") {\n\t\t\t\t\t\t\t\t\tfor (let i = series.dataItems.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\t\t\t\tlet item = series.dataItems[i];\n\t\t\t\t\t\t\t\t\t\tif (key && item.get(key as any) === searchCategory) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem = item;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (openKey && item.get(openKey as any) === searchCategory) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem = item;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (let i = 0, len = series.dataItems.length; i < len; i++) {\n\t\t\t\t\t\t\t\t\t\tlet item = series.dataItems[i];\n\t\t\t\t\t\t\t\t\t\tif (key && item.get(key as any) === searchCategory) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem = item;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (openKey && item.get(openKey as any) === searchCategory) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem = item;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!dataItem) {\n\t\t\t\t\t\t\t\t\tidx += direction === \"previous\" ? -1 : 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn dataItem;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstartDataItem = findDataItem(series, this, key, openKey, startCategory, \"next\");\n\t\t\t\t\t\tendDataItem = findDataItem(series, this, key, openKey, endCategory, \"previous\");\n\n\t\t\t\t\t\tlet startIndex = 0;\n\t\t\t\t\t\tlet endIndex = series.dataItems.length;\n\n\t\t\t\t\t\tif (startDataItem) {\n\t\t\t\t\t\t\tstartIndex = series.dataItems.indexOf(startDataItem);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (endDataItem) {\n\t\t\t\t\t\t\tendIndex = series.dataItems.indexOf(endDataItem) + 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseries.setPrivate(\"startIndex\", startIndex);\n\t\t\t\t\t\tseries.setPrivate(\"endIndex\", endIndex);\n\n\t\t\t\t\t\tlet hasValue = false;\n\t\t\t\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\t\t\t\tconst dataItem = series.dataItems[i];\n\n\t\t\t\t\t\t\t$array.each(series.__valueXShowFields, (key) => {\n\t\t\t\t\t\t\t\tlet value = dataItem.get(<any>key);\n\t\t\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\t\t\thasValue = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t$array.each(series.__valueYShowFields, (key) => {\n\t\t\t\t\t\t\t\tlet value = dataItem.get(<any>key);\n\t\t\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\t\t\thasValue = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\tif (hasValue) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseries.setPrivate(\"outOfSelection\", !hasValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseries._markDirtyAxes();\t// must be outside\n\t\t\t}\n\t\t})\n\t}\n\n\n\tprotected _prepareAxisItems() {\n\t\tconst renderer = this.get(\"renderer\");\n\t\tconst len = this.dataItems.length;\n\n\t\tlet startIndex = this.startIndex();\n\t\tif (startIndex > 0) {\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tlet endIndex = this.endIndex();\n\t\tif (endIndex < len) {\n\t\t\tendIndex++;\n\t\t}\n\n\t\tconst minorLabelsEnabled = renderer.get(\"minorLabelsEnabled\");\n\t\tconst minorGridEnabled = renderer.get(\"minorGridEnabled\", minorLabelsEnabled);\n\n\t\tlet maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\")!, 1);\n\n\t\tlet frequency = Math.max(1, Math.min(len, Math.ceil((endIndex - startIndex) / maxCount)));\n\n\t\tstartIndex = Math.floor(startIndex / frequency) * frequency;\n\t\tthis._frequency = frequency;\n\n\t\tfor (let j = 0; j < len; j++) {\n\t\t\tthis._toggleDataItem(this.dataItems[j], false);\n\t\t}\n\n\t\tlet f = this.dataItems[startIndex].get(\"index\", 0);\n\n\t\tfor (let i = startIndex; i < endIndex; i = i + frequency) {\n\t\t\tlet dataItem = this.dataItems[i];\n\n\t\t\tthis._createAssets(dataItem, []);\n\t\t\tthis._toggleDataItem(dataItem, true);\n\n\t\t\tlet count = frequency;\n\t\t\tif (minorGridEnabled) {\n\t\t\t\tcount = 1;\n\t\t\t}\n\n\t\t\tthis._prepareDataItem(dataItem, f, count);\n\n\t\t\tf++;\n\t\t}\n\n\t\tif (renderer.get(\"minorGridEnabled\")) {\n\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\tlet dataItem = this.dataItems[i];\n\t\t\t\tif (i % frequency != 0) {\n\t\t\t\t\tthis._createAssets(dataItem, [\"minor\"], true);\n\t\t\t\t\tthis._toggleDataItem(dataItem, true);\n\t\t\t\t\tthis._prepareDataItem(dataItem, 0, 1);\n\n\t\t\t\t\tif (!minorLabelsEnabled) {\n\t\t\t\t\t\tdataItem.get(\"label\")?.setPrivate(\"visible\", false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._updateGhost();\n\t}\n\n\n\tpublic _prepareDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, fillIndex?: number, count?: number) {\n\t\tlet renderer = this.get(\"renderer\");\n\n\t\tlet categoryLocation = dataItem.get(\"categoryLocation\", 0);\n\t\tlet endCategoryLocation = dataItem.get(\"endCategoryLocation\", 1);\n\n\t\tlet index: number | undefined = dataItem.get(\"index\");\n\n\t\tif (!$type.isNumber(index)) {\n\t\t\tindex = this.categoryToIndex(dataItem.get(\"category\")!);\n\t\t}\n\n\t\tlet position = this.indexToPosition(index, categoryLocation);\n\n\t\tlet endCategory = dataItem.get(\"endCategory\")!;\n\t\tlet endIndex: number;\n\t\tif (endCategory) {\n\t\t\tendIndex = this.categoryToIndex(endCategory);\n\t\t\tif (!$type.isNumber(endIndex)) {\n\t\t\t\tendIndex = index;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tendIndex = index;\n\t\t}\n\n\t\tlet endPosition = this.indexToPosition(endIndex, endCategoryLocation);\n\n\t\tlet fillEndIndex: number;\n\t\tlet fillEndPosition: number;\n\n\t\tif (dataItem.get(\"isRange\")) {\n\t\t\tfillEndIndex = endIndex;\n\n\t\t\tif (!$type.isNumber(index)) {\n\t\t\t\tthis._toggleDataItem(dataItem, false);\n\t\t\t\treturn;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfillEndIndex = index + this._frequency - 1;\n\t\t}\n\n\t\tfillEndPosition = this.indexToPosition(fillEndIndex, endCategoryLocation);\n\n\t\trenderer.updateLabel(dataItem.get(\"label\"), position, endPosition, count);\n\t\trenderer.updateGrid(dataItem.get(\"grid\"), position, endPosition);\n\t\trenderer.updateTick(dataItem.get(\"tick\"), position, endPosition, count);\n\t\trenderer.updateFill(dataItem.get(\"axisFill\"), position, fillEndPosition);\n\n\t\tthis._processBullet(dataItem);\n\t\trenderer.updateBullet(dataItem.get(\"bullet\"), position, endPosition);\n\n\t\tconst fillRule = this.get(\"fillRule\");\n\t\tif (fillRule) {\n\t\t\tfillRule(dataItem, fillIndex)\n\t\t}\n\t}\n\n\tpublic startIndex() {\n\t\tlet len = this.dataItems.length;\n\t\treturn Math.min(Math.max(this.getPrivate(\"startIndex\", 0), 0), len - 1);\n\t}\n\n\tpublic endIndex() {\n\t\tlet len = this.dataItems.length;\n\t\treturn Math.max(1, Math.min(this.getPrivate(\"endIndex\", len), len));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic baseValue(): any {\n\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic basePosition() {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Returns X coordinate in pixels corresponding to specific category index.\n\t *\n\t * @param   value  Index\n\t * @return         X coordinate\n\t */\n\tpublic getX(value: string): number {\n\t\tlet axisDataItem = this._itemMap[value];\n\t\tif (axisDataItem) {\n\t\t\treturn this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get(\"index\", 0)));\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * Returns Y coordinate in pixels corresponding to specific category index.\n\t *\n\t * @param   value  Index\n\t * @return         Y coordinate\n\t */\n\tpublic getY(value: string): number {\n\t\tlet axisDataItem = this._itemMap[value];\n\t\tif (axisDataItem) {\n\t\t\treturn this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get(\"index\", 0)));\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\tconst category = dataItem.get(field as any);\n\t\tconst axisDataItem = this._itemMap[category];\n\n\t\tif (axisDataItem) {\n\t\t\treturn this.indexToPosition(axisDataItem.get(\"index\", 0), cellLocation);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, _axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\tconst category = dataItem.get(field as any);\n\t\tconst axisDataItem = this._itemMap[category];\n\t\tif (axisDataItem) {\n\t\t\treturn this.indexToPosition(axisDataItem.get(\"index\", 0), cellLocation);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, _axisLocation));\n\t}\n\n\t/**\n\t * Converts category index to a relative position.\n\t *\n\t * `location` indicates relative position within category: 0 - start, 1 - end.\n\t *\n\t * If not set, will use middle (0.5) of the category.\n\t *\n\t * @param   index     Index\n\t * @param   location  Location\n\t * @return            Index\n\t */\n\tpublic indexToPosition(index: number, location?: number, final?: boolean): number {\n\t\tlet len = this.dataItems.length;\n\t\tlet position = 0;\n\n\t\tif (len == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (index >= len) {\n\t\t\tindex = len - 1;\n\t\t\tlocation = 1;\n\t\t}\n\n\t\tif (!$type.isNumber(location)) {\n\t\t\tlocation = 0.5;\n\t\t}\n\n\t\tif (!$type.isNumber(index)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet startLocation = this.get(\"startLocation\", 0);\n\t\tlet endLocation = this.get(\"endLocation\", 1);\n\n\t\tif (!this.get(\"cellSizeField\")) {\n\t\t\tlen -= startLocation;\n\t\t\tlen -= (1 - endLocation);\n\n\t\t\tposition = (index + location - startLocation) / len;\n\t\t}\n\t\telse {\n\t\t\tlet name: \"finalCellSize\" | \"cellSize\" = final ? \"finalCellSize\" : \"cellSize\";\n\n\t\t\tconst dataItems = this.dataItems;\n\n\t\t\t// Calculate total modified count (sum of cell sizes)\n\t\t\tlet modCount = 0;\n\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\tmodCount += dataItem.get(name, 1);\n\t\t\t});\n\n\t\t\tmodCount -= startLocation * dataItems[0].get(name, 1);\n\t\t\tmodCount -= (1 - endLocation) * dataItems[dataItems.length - 1].get(name, 1);\n\n\t\t\t// Calculate the position based on cell sizes\n\t\t\tlet acc = 0;\n\t\t\tfor (let i = 0; i < index; i++) {\n\t\t\t\tacc += dataItems[i].get(name, 1);\n\t\t\t}\n\t\t\tlet cellSizeAtIndex = dataItems[index].get(name, 1);\n\n\t\t\tposition = (acc + location * cellSizeAtIndex - startLocation * dataItems[0].get(name, 1)) / modCount;\n\t\t}\n\n\t\tif (!final) {\n\t\t\tlet dataItem = this.dataItems[index];\n\t\t\tif (dataItem) {\n\t\t\t\tposition += dataItem.get(\"deltaPosition\", 0);\n\t\t\t}\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t/**\n\t * Returns a position of a category.\n\t *\n\t * @param   category  Category to look up\n\t * @return            Position\n\t */\n\tpublic categoryToPosition(category: string): number {\n\t\tlet dataItem = this._itemMap[category];\n\t\tif (dataItem) {\n\t\t\treturn this.indexToPosition(dataItem.get(\"index\")!);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\n\t/**\n\t * Returns an index of a category.\n\t *\n\t * @param   category  Category to look up\n\t * @return            Index\n\t */\n\tpublic categoryToIndex(category: string): number {\n\t\tlet dataItem = this._itemMap[category];\n\t\tif (dataItem) {\n\t\t\treturn dataItem.get(\"index\")!;\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic dataItemToPosition(dataItem: DataItem<this[\"_dataItemSettings\"]>): number {\n\t\treturn this.indexToPosition(dataItem.get(\"index\")!);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic roundAxisPosition(position: number, location: number): number {\n\t\tposition += (0.5 - location) / this.dataItems.length;\n\t\treturn this.indexToPosition(this.axisPositionToIndex(position), location);\n\t}\n\n\t/**\n\t * Returns an index of the category that corresponds to specific pixel\n\t * position within axis.\n\t *\n\t * @param position  Position (px)\n\t * @return Category index\n\t */\n\tpublic axisPositionToIndex(position: number): number {\n\t\tlet len = this.dataItems.length;\n\t\tif (len === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Calculate total modified length (sum of cell sizes)\n\t\tif (this.get(\"cellSizeField\")) {\n\t\t\tlet modifiedLen = 0;\n\t\t\tlet cellSizes: number[] = [];\n\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\tconst cellSize = dataItem.get(\"cellSize\", 1);\n\t\t\t\tcellSizes.push(cellSize);\n\t\t\t\tmodifiedLen += cellSize;\n\t\t\t});\n\t\t\t// Adjust for startLocation and endLocation\n\t\t\tlet startLocation = this.get(\"startLocation\", 0);\n\t\t\tlet endLocation = this.get(\"endLocation\", 1);\n\t\t\tmodifiedLen -= startLocation;\n\t\t\tmodifiedLen -= (1 - endLocation);\n\n\t\t\t// Find which cell the position falls into\n\t\t\tlet rel = position * modifiedLen + startLocation;\n\t\t\tlet acc = 0;\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst cellSize = cellSizes[i];\n\t\t\t\tif (rel < acc + cellSize) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t\tacc += cellSize;\n\t\t\t}\n\t\t\treturn len - 1;\n\t\t}\n\t\telse {\n\t\t\treturn $math.fitToRange(Math.floor(position * len), 0, len - 1);\n\t\t}\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number, _adjustPosition?: boolean): string | undefined {\n\t\t//@todo number formatter + tag\n\t\tconst dataItem = this.dataItems[this.axisPositionToIndex(position)];\n\t\tif (dataItem) {\n\t\t\tconst label = dataItem.get(\"label\")\n\t\t\tif (label) {\n\t\t\t\treturn populateString(label, this.get(\"tooltipText\", \"\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _updateTooltipText(tooltip: Tooltip, position: number) {\n\t\ttooltip._setDataItem(this.dataItems[this.axisPositionToIndex(position)]);\n\t\ttooltip.label.text.markDirtyText();\n\t}\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number): DataItem<IXYSeriesDataItem> | undefined {\n\t\tif (this.dataItems.length > 0) {\n\t\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\t\tlet index = this.axisPositionToIndex(position);\n\t\t\t// try simple first\n\t\t\tlet seriesDataItem = series.dataItems[index];\n\t\t\tlet axisDataItem = this.dataItems[index];\n\t\t\tlet category = axisDataItem.get(\"category\");\n\n\t\t\tif (seriesDataItem && axisDataItem) {\n\t\t\t\tif (seriesDataItem.get(fieldName) === category) {\n\t\t\t\t\treturn seriesDataItem;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if not found, try looking\n\t\t\tfor (let i = 0, len = series.dataItems.length; i < len; i++) {\n\t\t\t\tlet dataItem = series.dataItems[i];\n\t\t\t\tif (dataItem.get(fieldName) === category) {\n\t\t\t\t\treturn dataItem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _getIndices(start: number, end: number): { startIndex: number, endIndex: number } {\n\t\tlet len = this.dataItems.length;\n\t\tlet startIndex = 0;\n\t\tlet endIndex = len;\n\t\tlet name: \"cellSize\" | \"finalCellSize\" = \"cellSize\";\n\n\t\tif (this.get(\"cellSizeField\")) {\n\t\t\tlet count = 0;\n\t\t\tconst dataItems = this.dataItems;\n\t\t\tif(dataItems.length == 0){\n\t\t\t\treturn { startIndex: 0, endIndex: 0 };\n\t\t\t}\n\n\t\t\t$array.each(dataItems, (dataItem) => {\n\t\t\t\tcount += dataItem.get(name, 1);\n\t\t\t});\n\n\t\t\tcount -= this.get(\"startLocation\", 0) * dataItems[0].get(name, 1);\n\t\t\tcount -= (1 - this.get(\"endLocation\", 1)) * dataItems[dataItems.length - 1].get(name, 1);\n\n\t\t\tlet c = 0;\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tc += this.dataItems[i].get(name, 1);\n\t\t\t\tif (Math.round(c) > Math.round(start * count)) {\n\t\t\t\t\tstartIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = startIndex + 1; i < len; i++) {\n\t\t\t\tc += this.dataItems[i].get(name, 1);\n\t\t\t\tif (Math.round(c) >= Math.round(end * count)) {\n\t\t\t\t\tendIndex = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstartIndex = Math.max(startIndex, 0);\n\t\t\tendIndex = Math.min(endIndex, len);\n\t\t}\n\t\telse {\n\t\t\tstartIndex = Math.max(Math.round(this.get(\"start\", 0) * len), 0);\n\t\t\tendIndex = Math.min(Math.round(this.get(\"end\", 1) * len), len);\n\t\t}\n\n\t\treturn { startIndex, endIndex };\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` indexes.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start index\n\t * @param  end       End index\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToIndexes(start: number, end: number, duration?: number) {\n\t\tlet len = this.dataItems.length;\n\t\tif (this.get(\"cellSizeField\")) {\n\t\t\tstart = Math.min(Math.max(start, 0), len);\n\t\t\tend = Math.max(Math.min(end, len), 1);\n\t\t\tthis.setPrivateRaw(\"startIndex\", start);\n\t\t\tthis.setPrivateRaw(\"endIndex\", end);\n\t\t\tthis.zoom(this.indexToPosition(start, 0, true), this.indexToPosition(end, 0, true), duration);\n\t\t}\n\t\telse {\n\t\t\tthis.zoom(start / len, end / len, duration);\n\t\t}\n\t}\n\n\tpublic zoomToCategories(startCategory: string, endCategory: string, duration?: number) {\n\t\tthis.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1, duration);\n\t}\n\n\t/**\n\t * Returns position span between start and end of a single cell in axis.\n\t *\n\t * @since 5.2.30\n\t * @return Position\n\t */\n\tpublic getCellWidthPosition(): number {\n\t\treturn this._frequency / this.dataItems.length / (this.get(\"end\", 1) - this.get(\"start\", 0));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic nextPosition(count?: number) {\n\t\tif (count == null) {\n\t\t\tcount = 1;\n\t\t}\n\n\t\tif (this.get(\"renderer\").getPrivate(\"letter\") == \"Y\") {\n\t\t\tcount *= -1;\n\t\t}\n\n\t\tconst position = this.getPrivate(\"tooltipPosition\", 0);\n\n\t\tconst index = $math.fitToRange(this.axisPositionToIndex(position) + count, 0, this.dataItems.length - 1);\n\t\treturn this.toGlobalPosition(this.indexToPosition(index));\n\t}\n}\n"],"names":["CategoryAxis","Axis","constructor","Object","defineProperty","_afterNew","this","_settings","themeTags","$utils","fields","push","setPrivateRaw","addTag","super","_afterDataChange","len","dataItems","length","Math","min","getPrivate","_prepareChildren","i","_valuesDirty","_itemMap","$array","dataItem","setRaw","get","start","end","indices","_getIndices","startIndex","endIndex","_sizeDirty","isDirty","isPrivateDirty","_handleRangeChange","_prepareAxisItems","_updateAxisRanges","adjustZoom","maxZoomCount","minZoomCount","count","sAnimation","_sAnimation","eAnimation","_eAnimation","getIndices","stopped","Number","to","c","zoomToIndexes","series","startCategory","endCategory","baseAxis","xAxis","yAxis","_markDirtyAxes","key","openKey","otherAxis","ValueAxis","startDataItem","endDataItem","findDataItem","categoryAxis","category","direction","idx","categoryToIndex","searchCategory","item","indexOf","setPrivate","hasValue","__valueXShowFields","__valueYShowFields","renderer","minorLabelsEnabled","minorGridEnabled","maxCount","axisLength","max","frequency","ceil","floor","_frequency","j","_toggleDataItem","f","_createAssets","_prepareDataItem","_a","_updateGhost","fillIndex","categoryLocation","endCategoryLocation","index","$type","position","indexToPosition","fillEndIndex","fillEndPosition","endPosition","updateLabel","updateGrid","updateTick","updateFill","_processBullet","updateBullet","fillRule","baseValue","basePosition","getX","value","axisDataItem","positionToCoordinate","NaN","getY","getDataItemPositionX","field","cellLocation","_axisLocation","getDataItemCoordinateX","getDataItemPositionY","getDataItemCoordinateY","location","final","startLocation","endLocation","name","modCount","acc","categoryToPosition","dataItemToPosition","roundAxisPosition","axisPositionToIndex","modifiedLen","cellSizes","cellSize","rel","$math","getTooltipText","_adjustPosition","label","populateString","_updateTooltipText","tooltip","_setDataItem","text","markDirtyText","getSeriesItem","fieldName","seriesDataItem","round","duration","zoom","zoomToCategories","getCellWidthPosition","nextPosition","toGlobalPosition","classNames","concat","className"],"sourceRoot":""}